import os, sys
import time
import json


# Add the lib directory to the sys.path for splunklib
sys.path.insert(0, os.path.join(os.path.dirname(__file__), "..", "lib"))

# Import necessary classes from splunklib
from splunklib.searchcommands import dispatch, GeneratingCommand, Configuration, Option, validators

@Configuration(local=True)
class BringBackDataCommand(GeneratingCommand):
    """
    A custom command that takes space-separated file paths,
    generates events for each, and creates/updates an inputs.conf file
    to monitor these files for ingestion into Splunk.

    Example:
    ``| bringbackdata field1="/var/log/my_app/file1.log /opt/data/report.csv" ingest_sourcetype="my_app_logs" ingest_index="my_archive" inputs_conf_path="/opt/splunk/etc/apps/MyCustomApp/local/inputs.conf"``
    """
    # The field containing space-separated file paths
    field1 = Option(require=True, name="field1")

    # Options for inputs.conf generation
    ingest_sourcetype = Option(require=False, default="archived_data_ingest")
    ingest_index = Option(require=False, default="archive")
    # This option will now be dynamically set by the dashboard
    inputs_conf_path = Option(require=True)


    def generate(self):
        """
        The main generator method for the Splunk custom command.
        It processes the input 'field1' value, yields new events,
        and generates the inputs.conf file.
        """
        field_value = self.field1
        items = field_value.split() # Split by space to get individual file paths

        # --- Prepare inputs.conf content ---
        inputs_conf_content = []
        inputs_conf_content.append("# This file was automatically generated by the bringbackdata custom command.")
        inputs_conf_content.append(f"# Generated on: {time.ctime()}")
        inputs_conf_content.append(f"# Command call: {' '.join(sys.argv)}")
        inputs_conf_content.append(f"# Files selected for ingestion with sourcetype='{self.ingest_sourcetype}' and index='{self.ingest_index}'")
        inputs_conf_content.append("#")
        inputs_conf_content.append("# For 'monitor://' inputs, the 'source' field in Splunk events will automatically be set to the full path of the monitored file.")
        inputs_conf_content.append("# To apply these changes, you MUST reload Splunk configurations (e.g., | rest /services/configs/conf-inputs/_reload) or restart Splunk.")
        inputs_conf_content.append("#")

        # Iterate over each item (file path) and generate events,
        # then add its stanza to the inputs.conf content.
        for item in items:
            if item and item.strip(): # Ensure item is not empty or just whitespace
                clean_item = item.strip()
                message = f'Preparing to bring back file: "{clean_item}". It will be ingested with sourcetype="{self.ingest_sourcetype}" into index="{self.ingest_index}".'
                yield {
                    '_time': time.time(),
                    'log_level': 'INFO',
                    'message': message,
                    '_raw': message,
                    'file_path': clean_item,
                    'ingest_sourcetype': self.ingest_sourcetype,
                    'ingest_index': self.ingest_index
                }

                # Add stanza for inputs.conf
                inputs_conf_content.append(f"\n[monitor://{clean_item}]")
                inputs_conf_content.append(f"sourcetype = {self.ingest_sourcetype}")
                inputs_conf_content.append(f"index = {self.ingest_index}")
                inputs_conf_content.append("disabled = false")
                inputs_conf_content.append("crcSalt = <SOURCE>") # Good practice for file monitoring
                inputs_conf_content.append("followTail = 0") # Start from beginning of file

        # --- Write to inputs.conf ---
        try:
            # Ensure the directory for inputs.conf exists
            conf_dir = os.path.dirname(self.inputs_conf_path)
            if not os.path.exists(conf_dir):
                self.logger.info(f"Creating directory for inputs.conf: {conf_dir}")
                os.makedirs(conf_dir, exist_ok=True) # Creates directories if they don't exist

            # Write the content to the inputs.conf file
            # Using 'w' will overwrite the file each time the command runs.
            with open(self.inputs_conf_path, 'w') as f:
                f.write("\n".join(inputs_conf_content))

            yield {
                '_time': time.time(),
                'log_level': 'INFO',
                'message': f"Successfully generated/updated inputs.conf at '{self.inputs_conf_path}' with {len(items)} entries.",
                '_raw': f"Successfully generated/updated inputs.conf at '{self.inputs_conf_path}' with {len(items)} entries.",
                'inputs_conf_path': self.inputs_conf_path,
                'num_files_configured': len(items)
            }
            yield {
                '_time': time.time(),
                'log_level': 'WARNING',
                'message': f"ACTION REQUIRED: To activate monitoring, reload Splunk configs (e.g., '| rest /services/configs/conf-inputs/_reload') or restart Splunk.",
                '_raw': f"ACTION REQUIRED: To activate monitoring, reload Splunk configs (e.g., '| rest /services/configs/conf-inputs/_reload') or restart Splunk."
            }

        except Exception as e:
            yield {
                '_time': time.time(),
                'log_level': 'ERROR',
                'message': f"Failed to write inputs.conf to '{self.inputs_conf_path}': {str(e)}. "
                           f"Please ensure the Splunk user has write permissions to '{conf_dir}'.",
                '_raw': f"Failed to write inputs.conf to '{self.inputs_conf_path}': {str(e)}. "
                        f"Please ensure the Splunk user has write permissions to '{conf_dir}'."
            }

# This is the entry point for the Splunk search command
dispatch(BringBackDataCommand, sys.argv, sys.stdin, sys.stdout, __name__)
